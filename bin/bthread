#!/usr/bin/env node
var bthread = require('../');
var utils = require('./utils');

var dns = require('dns');
var net = require('net');
var path = require('path');
var os = require('os');
var spawn = require('child_process').spawn;
var fs = require('fs');

var progress = require('progress');
var prompt = require('prompt');
var leveldown = require('leveldown');

var argv = require('yargs')
    .demand([ 'host' ])
    .alias('h', 'host')
    .alias('p', 'passphrase')
    .alias('c', 'post-cost')
    .argv;

var addrs = [
  'seed.bitcoin.sipa.be',
  'dnsseed.bluematt.me',
  'dnsseed.bitcoin.dashjr.org',
  'seed.bitcoinstats.com',
  'seed.bitnodes.io',
  'bitseed.xf2.org'
];

var logger = utils.logger();

logger.log('Welcome to BThread');
logger.log('You are going to start participating on: %s', argv.host);
if (argv.passphrase)
  return onPassphrase(null, { passphrase: argv.passphrase });

logger.log('Please supply your passphrase so we will be able to identify you');
prompt.start();
prompt.get({
  properties: {
    passphrase: {
      hidden: true
    }
  }
}, function(err, result) {
  prompt.pause();
  onPassphrase(err, result);
});

var thread;

function onPassphrase(err, result) {
  if (err) {
    logger.log('Cancelled');
    return process.exit();
  }

  var pass = result.passphrase;

  thread = new bthread({
    db: leveldown,
    dbPath: path.resolve(__dirname, '..', 'db'),
    host: argv.host,
    passphrase: pass,
    postCost: argv.postCost,

    resolveTxt: dns.resolveTxt,

    createConnection: function() {
      return net.connect(8333, addrs[(Math.random() * addrs.length) | 0]);
    }
  });

  thread.once('dns-record', function(r) {
    logger.log('===================================================');
    logger.log('Set this as TXT record for %s:', argv.host);
    logger.log('    ' + r);
    logger.log('===================================================');
  });

  var searchBar = null;
  var searchLast = 0;
  thread.on('search', function(range, a, b) {
    if (logger.paused !== 0)
      return;
    if (!searchBar || searchBar.total !== b) {
      var start = new Date(range.start * 1000).toDateString();
      var end = new Date(range.end * 1000).toDateString();
      searchBar = new progress('  searching ' + start + ' -> ' + end +
                               ' [:bar] :etas', {
        total: b,
        width: 20
      });
      searchLast = 0;
    }
    searchBar.tick(a - searchLast);
    searchLast = a;
  });

  thread.on('log', function() {
    logger.log.apply(logger, arguments);
  });

  thread.on('balance', function() {
    logger.log('Wallet balance updated: %s', thread.balance.toString(10));
  });

  thread.on('wallet', function(addr, kind) {
    if (kind === 'self') {
      logger.log('Your wallet is %s', addr);
    } else {
      logger.log('Thread owner\'s wallet is %s', addr);
    }
  });

  thread.once('search-end', function() {
    start();
  });
}

function start() {
  if (argv._[0] === 'post')
    return post();
}

function post() {
  var tmpFile = path.resolve(os.tmpDir(), (+new Date) + Math.random() + '.bt');
  var ed = process.env.EDITOR || 'vim';
  if (!process.env.EDITOR)
    logger.log('No EDITOR env variable found, spawning %s', ed);

  var line = 'Please write your BThread message here\n';
  fs.writeFileSync(tmpFile, 'Please write your BThread message here\n');
  ed = spawn(ed, [ tmpFile ], {
    stdio: [ 0, 1, 2 ]
  });

  var postMsg = null;
  ed.once('close', function() {
    var msg = fs.readFileSync(tmpFile).toString();

    // Skip predefined string
    if (msg.slice(0, line.length) === line)
      msg = msg.slice(line.length);

    if (msg.length === 0) {
      logger.log('Error: message file is empty');
      process.exit(1);
      return;
    }

    postMsg = msg;
    thread.post(postMsg, onPost);
  });

  function onPost(err, hash) {
    if (err && err.minBalance)
      return retry(err.minBalance);
    if (err)
      throw err;
    logger.log('Messages posted, the TX hash is %s', hash);
  }

  function retry(balance) {
    logger.log('');
    logger.log('You don\'t have enough bitcoins to post a message');
    logger.log('Minimum required value is %s satoshi (~%d BTC)',
               balance.toString(10),
               balance.toString(10) / 10000000);
    logger.log('Please send some to your address: %s to continue',
               thread.wallet.self.getAddress());

    // Retry later
    thread.once('balance', function() {
      if (this.balance.cmp(balance) >= 0)
        this.post(postMsg, onPost);
    });
  }
}
